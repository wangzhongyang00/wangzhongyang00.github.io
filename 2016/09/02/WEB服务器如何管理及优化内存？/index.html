<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>WEB服务器如何管理及优化内存？ | 王中阳 | 汇细流，成江海；积跬步，致千里。</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
  
  <meta name="theme-color" content="#3F51B5">
  
  
  <meta name="keywords" content="大数据">
  <meta name="description" content="第三方文档

本文参考链接，感谢作者

节选自上文链接的思路


Ngnix+PHP-FPM的工作方式，似乎是最节省系统资源的web系统工作方式。
当然，具体的技术选型更多的应该参考自己想买的业务需求。

一 原因：越来越多的并发连接数
页面的元素增多，交互复杂
主流浏览器的连接数在增加

二 辅助方案：通过WEB前端优化，降低服务器的压力
减少web请求
减轻web请求
合并页面请求

三 推">
<meta property="og:type" content="article">
<meta property="og:title" content="WEB服务器如何管理及优化内存？">
<meta property="og:url" content="http://wangzhongyang.ren/2016/09/02/WEB服务器如何管理及优化内存？/index.html">
<meta property="og:site_name" content="王中阳">
<meta property="og:description" content="第三方文档

本文参考链接，感谢作者

节选自上文链接的思路


Ngnix+PHP-FPM的工作方式，似乎是最节省系统资源的web系统工作方式。
当然，具体的技术选型更多的应该参考自己想买的业务需求。

一 原因：越来越多的并发连接数
页面的元素增多，交互复杂
主流浏览器的连接数在增加

二 辅助方案：通过WEB前端优化，降低服务器的压力
减少web请求
减轻web请求
合并页面请求

三 推">
<meta property="og:updated_time" content="2016-09-02T10:45:42.508Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="WEB服务器如何管理及优化内存？">
<meta name="twitter:description" content="第三方文档

本文参考链接，感谢作者

节选自上文链接的思路


Ngnix+PHP-FPM的工作方式，似乎是最节省系统资源的web系统工作方式。
当然，具体的技术选型更多的应该参考自己想买的业务需求。

一 原因：越来越多的并发连接数
页面的元素增多，交互复杂
主流浏览器的连接数在增加

二 辅助方案：通过WEB前端优化，降低服务器的压力
减少web请求
减轻web请求
合并页面请求

三 推">
  
    <link rel="alternative" href="/atom.xml" title="王中阳" type="application/atom+xml">
  
  <meta name="summary" content="null">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/style.css">
</head></html>
<body>
  <div id="loading" class="active"></div>
  <nav id="menu" class="hide">
   <div class="inner flex-row-vertical">
  <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
      <i class="icon icon-lg icon-close"></i>
  </a>
  <div class="brand-wrap">
    <div class="brand">
      <a href="/" class="avatar"><img src="/img/avatar.gif"></a>
      <hgroup class="introduce">
        <h5 class="nickname">王中阳</h5>
        <a href="mailto:425772719@qq.com" title="425772719@qq.com" class="mail">425772719@qq.com</a>
      </hgroup>
    </div>
  </div>
  <ul class="nav flex-col">
    
        <li class="waves-block waves-effect">
          <a href="/">
            <i class="icon icon-lg icon-home"></i>
            主页
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="/archives">
            <i class="icon icon-lg icon-archives"></i>
            归档
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="/tags">
            <i class="icon icon-lg icon-tags"></i>
            标签
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="http://blog.csdn.net/w425772719" target="_blank">
            <i class="icon icon-lg icon-heart"></i>
            CSDN
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="https://github.com/wangzhongyang00" target="_blank">
            <i class="icon icon-lg icon-github"></i>
            github
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="/about">
            <i class="icon icon-lg icon-link"></i>
            关于
          </a>
        </li>
    
  </ul>

  <footer class="footer">
  <p><a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0;vertical-align:middle" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAAllBMVEUAAAD///+rsapERER3d3eIiIjMzMzu7u4iIiKUmZO6v7rKzsoODg4RERFVVVUNDQ0NDg0PEA8zMzNLTEtbXltmZmZydnF9gn2AgICPkI+ZmZmqqqq7u7vFxsXIzMgNDQwZGRkgICAhISEkJSMnKCcuMC4xMzE5Ozk7PTtBQkFCQkJDQ0Nna2eGhoaHh4ezuLLGysbd3d1wVGpAAAAA4UlEQVR42q2T1xqCMAyFk7QsBQeKA9x7j/d/OSm22CpX0nzcpA1/T05aAOuBVkMAScQFHLnEwoCo2f1TnQIGoVMewjZEjVFN4GH1Ue1Cn2jWqwfsOOj6wDwGvotsl/c8lv7KIq1eLOsT0HMFHMIE/RZyHnlphryT9zyV+8WH5e8yQw3wnQvgAFxPTKUVi555SHR/lOfLMgVTeDlSfN+TaoUsiTyeIm+bCkHvCA2FUKG48LDtYBZBknsYP/G8NTw0gaaHyuQf4H5pecrB/FYCT2sL9zAfy1Xyjou6L8X2W7YcLyBZCRtnq/zfAAAAAElFTkSuQmCC"></a></p>
  <p>王中阳 &copy; 2016</p>
  <p>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme
  <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></p>
  <a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-2x icon-rss-square"></i></a>
</footer>
</div>
  </nav>
  <main id="main">
    <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">WEB服务器如何管理及优化内存？</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
    </div>
</header>
<header class="content-header">
  <div class="container">
    <h1 class="author">WEB服务器如何管理及优化内存？</h1>
    <h5 class="subtitle">
        
            <time datetime="2016-09-02T10:42:34.000Z" itemprop="datePublished" class="page-time">
  2016-09-02
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/大数据/">大数据</a></li></ul>
        
    </h5>
  </div>
</header>
    <div class="container body-wrap">
      <article id="post-WEB服务器如何管理及优化内存？" class="article article-type-post" itemprop="blogPost">
    <div class="post-meta flex-row">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/大数据/">大数据</a></li></ul>
    </div>
    <div class="post-body">
        <aside class="post-widget" id="post-widget">

            

            
            <nav class="post-toc-wrap" id="post-toc">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#一-原因：越来越多的并发连接数"><span class="post-toc-number">1.</span> <span class="post-toc-text">一 原因：越来越多的并发连接数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#二-辅助方案：通过WEB前端优化，降低服务器的压力"><span class="post-toc-number">2.</span> <span class="post-toc-text">二 辅助方案：通过WEB前端优化，降低服务器的压力</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#三-推荐方案：节约web服务器的内存"><span class="post-toc-number">3.</span> <span class="post-toc-text">三 推荐方案：节约web服务器的内存</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#四-节约web服务器的CPU"><span class="post-toc-number">4.</span> <span class="post-toc-text">四 节约web服务器的CPU</span></a></li></ol><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#这里顺便提到一下，经常和Nginx搭配工作的PHP-FPM（FastCGI）使用的是多进程，因此不会有线程安全的问题。"><span class="post-toc-number"></span> <span class="post-toc-text">这里顺便提到一下，经常和Nginx搭配工作的PHP-FPM（FastCGI）使用的是多进程，因此不会有线程安全的问题。</span></a>
            </li></nav>
            
        </aside>

        <div class="post-main">

            <div class="post-content" id="post-content" itemprop="postContent">
            <blockquote>
<p>第三方文档</p>
</blockquote>
<p><a href="http://www.cnblogs.com/web-ed2/articles/4315540.html" target="_blank" rel="external">本文参考链接，感谢作者</a></p>
<blockquote>
<p>节选自上文链接的思路</p>
</blockquote>
<ol>
<li>Ngnix+PHP-FPM的工作方式，似乎是最节省系统资源的web系统工作方式。</li>
<li>当然，具体的技术选型更多的应该参考自己想买的业务需求。</li>
</ol>
<h4 id="一-原因：越来越多的并发连接数"><a href="#一-原因：越来越多的并发连接数" class="headerlink" title="一 原因：越来越多的并发连接数"></a>一 原因：越来越多的并发连接数</h4><ol>
<li>页面的元素增多，交互复杂</li>
<li>主流浏览器的连接数在增加</li>
</ol>
<h4 id="二-辅助方案：通过WEB前端优化，降低服务器的压力"><a href="#二-辅助方案：通过WEB前端优化，降低服务器的压力" class="headerlink" title="二 辅助方案：通过WEB前端优化，降低服务器的压力"></a>二 辅助方案：通过WEB前端优化，降低服务器的压力</h4><ol>
<li>减少web请求</li>
<li>减轻web请求</li>
<li>合并页面请求</li>
</ol>
<h4 id="三-推荐方案：节约web服务器的内存"><a href="#三-推荐方案：节约web服务器的内存" class="headerlink" title="三 推荐方案：节约web服务器的内存"></a>三 推荐方案：节约web服务器的内存</h4><ol>
<li>prefork MPM(Apache服务器多道处理器模块),多进程工作模式：<ol>
<li>主进程生成后，他先完成初始化的工作，通过fork的方式预先产生一批子进程（子进程复制父进程的内存空间，不需要再做初始化的工作）</li>
<li>多进程的好处：进程之间的内存数据是互不干扰的。</li>
<li>优点：成熟稳定，兼容新老版本，不用担心线程安全的问题</li>
<li>缺点：不适合高并发的业务场景，一个服务进程占很多内存</li>
</ol>
</li>
<li>worker MPM, 多线程和多进程的混合模式<ol>
<li>和prework一样，也预先fork了几个子进程（数量少），然后每个子进程创建几个线程（包含一个监听线程）。每个请求过来，会交给一个线程来服务。（线程比进程轻量级，所以内存占用更少）。</li>
<li>注意：并没有解决“keep-alive”长连接的问题，只是把对象编程了更轻量级的线程</li>
<li>疑问:既然多线程轻量级，为什么不完全采用多线程的方式呢？因为多进程能确保程序的稳定性，如果采用单进程多线程的方式，有一个线程挂了，那么该进程下的其他线程也挂了，会导致全军覆没。</li>
<li>优点：更优秀的内存管理，高并发场景下表现更优秀。</li>
<li>缺点：需要考虑线程安全问题，需要引入锁，加大cpu的消耗。</li>
</ol>
</li>
<li>event MPM<ol>
<li>和worker的方式很像，最大的差别在于解决了“keep-alive”场景下，长期被占用的线程资源问题。</li>
<li>注意:event MPM遇到不兼容的模块时会失效，将回退到worker模式，一个工作线程处理一个请求。</li>
<li>Apache的3种模式中，event MPM是最节约内存的。（需要Linux系统对<a href="http://baike.baidu.com/link?url=F6mSjthXnihIvZp2g50AA82xZYqR2GYnZ0mkUpslkaocR-ii0yyLfzDu-J2zWiriOXrojEcUSMQk_va4PcIQZ_" target="_blank" rel="external">Epoll</a>的支持才能启用）</li>
</ol>
</li>
<li>使用轻量级的Ngnix作为web服务器<ol>
<li>Ngnix本身就是一个轻量级的web服务器，天生萝莉，比Apache要轻量。</li>
<li><a href="http://baike.baidu.com/link?url=96gLGLWl0PaGX4-PdWgRU0FzC5pdQ-5aqCFvk6iPYo2dymFLeX8dVENX8ocsOIrnExZRY_OBnIl2d2-Ai-wy3a" target="_blank" rel="external">Ngnix</a>通过一个进程来服务N个链接，采用的方式不同于Apache的方式。</li>
</ol>
</li>
<li>sendfile节约内存（这个概念非常重要）<ol>
<li>sendfile可以减少数据到“用户态内存空间”（用户缓存区）的拷贝，进而减少对内存的占用。</li>
<li>为了更好的理解上面所说的原理。笔者先引入下面的概念：<a href="http://www.cnblogs.com/viviwind/archive/2012/09/22/2698450.html" target="_blank" rel="external">内核态和用户态的区别</a>，内核态的优先级高Ring0，而用户态（运行态）的优先级低Ring3;并且当执行用户程序是突然中断，运行状态会从“用户态”切换到“内核态”。</li>
<li>一般情况下，用户态（程序所在的内存空间）不能直接操作（读写等）各种设备（磁盘，网络，终端等）的。需要使用<a href="http://baike.baidu.com/link?url=-VyqJDrRt-lnKOnzZjx1wRmJxdFTYQibhqwmmm67D6kRUGbDD2uIL-zIa5OWmONglCgLMgiv0b6BTMjRWoPNX_" target="_blank" rel="external">内核</a>作为中间人来完成对设备的操作。</li>
<li>来吃个栗子（例子）吧：以最简单的磁盘读写为例，从磁盘A读取文件到磁盘B,其过程是这样的：A文件数据从磁盘开始，然后载入到“内核缓冲区”，然后拷贝到“用户缓存区”，这完成了读操作。写操作也是一样的，从“用户缓存区”拷贝到“内核缓冲区”，最后写入到磁盘B中。</li>
<li>这样读写文件很累吧。有大神提出了要删繁就简，取消“用户缓存区”那部分拷贝工作，引入了MMP（Memory-Mapping，内存映射）的概念。实现原理是这样的：建立一个磁盘空间和内存的直接映射，数据不再拷贝到“用户缓存区”，而是返回一个指向内存空间的指针。这样我们之前的文件拷贝就变成了如下步骤：A磁盘中文件将数据载入到“内核缓冲区”，B磁盘从“内核缓冲区”拷贝写入文件。减少了一次拷贝过程，减少了内存的占用。</li>
<li>回到正题：简单来说，sendfile的原理和mmp的方式类似，核心也是减少了“内核缓冲区”到“用户缓冲区”的拷贝。</li>
<li>优点： 不仅节省了内存，还节省了CPU的开销。</li>
</ol>
</li>
</ol>
<h4 id="四-节约web服务器的CPU"><a href="#四-节约web服务器的CPU" class="headerlink" title="四 节约web服务器的CPU"></a>四 节约web服务器的CPU</h4><ol>
<li>对于web服务器而言，CPU是另一个非常核心的系统资源。就web服务器而言，除了业务程序消耗CPU外，多线程/多进程的上下文切换，也是比较消耗CPU资源的。</li>
<li>一个进程/线程无法长时间占用CPU，当发生阻塞或者<a href="http://baike.baidu.com/link?url=eUI15AuqbxTgT0KcV58mVbhAcdi-kr9ltue5nr-cL8RQtO2RXnupCqe3htS05Em5xthAdfebQNnJ9C3fny13bK" target="_blank" rel="external">时间片</a>用完时，就无法继续占用CPU，这时会发生时间上下文的切换，即老的时间片切换到新的时间片，也是耗CPU的。</li>
<li>在并发连接数目很高的情况下，去轮询检测用户建立的连接状态（socket文件描述符），也是消耗CPU的。</li>
<li>笔者在这里只介绍一下终极问题及解决办法：</li>
</ol>
<blockquote>
<p>多线程下的锁对CPU的开销</p>
</blockquote>
<ol>
<li><p>Apache中的worker和event模式，都有采用多线程。多线程因为共享父进程的内存空间，在访问共享数据的时候，就会产生竞争，也就是线程安全问题。因此通常会引入锁（Linux下比较常用的线程相关的锁有互斥量<a href="http://baike.baidu.com/link?url=OaFzEcqZUL3YxsGOsm-ddMmlcsySLgKia6ooMFWdYvsyCVG4L-m7ENKuZ-oiF2jtjy9X9QtColdu2Q_L2viRjUQD6jQRBh-gWOylaRHwzwm" target="_blank" rel="external">metux</a>，读写锁<a href="http://baike.baidu.com/view/2214179.htm" target="_blank" rel="external">rwlock</a>等），成功获取锁的线程可以继续执行，获取失败的通常选择阻塞等待。引入锁的机制，程序的复杂度往往增加不少，同时还有线程“死锁”或者“饿死”的风险（多进程在访问进程间共享资源的时候，也有同样的问题）。</p>
</li>
<li><p>死锁现象（两个线程彼此锁住对方想要获取的资源，相互阻塞等待，永远无法达不到满足条件）</p>
</li>
<li>饿死现象（某个线程，一直获取不到它想要锁资源，永远无法执行下一步）</li>
<li><p>为了避免这些锁导致的问题，就不得不加大程序的复杂度，解决方案一般有：</p>
<ol>
<li><p>对资源的加锁，根据约定好的顺序，大家都先对共享资源X加锁，加锁成功之后才能加锁共享资源Y。</p>
</li>
<li><p>如果线程占有资源X，却加锁资源Y失败，则放弃加锁，同时也释放掉之前占有的资源X。</p>
</li>
</ol>
</li>
<li><p>在使用PHP的时候，在Apache的worker和event模式下，也必须兼容线程安全。通常，新版本的PHP官方库是没有线程安全方面的问题，需要关注的是第三方扩展。PHP实现线程安全，不是通过锁的方式实现的。而是为每个线程独立申请一份全局变量的副本，相当于线程的私人内存空间，但是这样做相对多消耗一些内存。这样的好处：不需要引入复杂的锁机制实现，也避免了锁机制对CPU的开销。</p>
</li>
</ol>
<h2 id="这里顺便提到一下，经常和Nginx搭配工作的PHP-FPM（FastCGI）使用的是多进程，因此不会有线程安全的问题。"><a href="#这里顺便提到一下，经常和Nginx搭配工作的PHP-FPM（FastCGI）使用的是多进程，因此不会有线程安全的问题。" class="headerlink" title="这里顺便提到一下，经常和Nginx搭配工作的PHP-FPM（FastCGI）使用的是多进程，因此不会有线程安全的问题。"></a>这里顺便提到一下，经常和Nginx搭配工作的PHP-FPM（FastCGI）使用的是多进程，因此不会有线程安全的问题。</h2><pre><code>笔者：王中阳 
微信（QQ）：425772719
公司：北京麦芽田网络科技有限公司
邮箱：wangzhong.yang@foxmail.com
本篇文章整理自==徐汉彬==老师的《高并发Web服务的演变——节约系统内存和CPU》
本篇文稿初步整理,如有不妥之处敬请谅解
欢迎在下方评论处交流讨论，欢迎纠正问题
</code></pre>
            <blockquote>
                <p>
                本文地址：
                <a href="http://wangzhongyang.ren/2016/09/02/WEB服务器如何管理及优化内存？/" target="_blank" rel="external">http://wangzhongyang.ren/2016/09/02/WEB服务器如何管理及优化内存？/</a>
                </p>
                <footer><cite><a href="http://wangzhongyang.ren">@王中阳</a></cite></footer>
            </blockquote>
            </div>
            <nav class="post-nav">
  

  
    <div class="waves-block waves-effect next fr">
      <a href="/2016/09/02/UI优化总结/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">UI优化总结</h4>
      </a>
    </div>
  
</nav>
            
            <div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="WEB服务器如何管理及优化内存？" data-title="WEB服务器如何管理及优化内存？" data-url="http://wangzhongyang.ren/2016/09/02/WEB服务器如何管理及优化内存？/index.html"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">var duoshuoQuery={short_name:"NNorLand"};!function(){var t=document.createElement("script");t.type="text/javascript",t.async=!0,t.src=("https:"==document.location.protocol?"https:":"http:")+"//static.duoshuo.com/embed.js",t.charset="UTF-8",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(t)}();</script><!-- 多说公共JS代码 end --></div></div></div></article></div></main><div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>
<script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script><script src="/js/main.js"></script><div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<script type="text/template" id="search-tpl">
<li class="item">
    <a href="/{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</script><script src="/js/search.js"></script><script src="http://s95.cnzz.com/z_stat.php?id=hooray_K@163.com&web_id=hooray_K@163.com"></script></body>